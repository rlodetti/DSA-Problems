# Longest Palindromic Substring

## Problem Description
<p>Given a string <code>s</code>, return <em>the longest</em> <span data-keyword="palindromic-string"><em>palindromic</em></span> <span data-keyword="substring-nonempty"><em>substring</em></span> in <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;babad&quot;
<strong>Output:</strong> &quot;bab&quot;
<strong>Explanation:</strong> &quot;aba&quot; is also a valid answer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cbbd&quot;
<strong>Output:</strong> &quot;bb&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> consist of only digits and English letters.</li>
</ul>


## Solution (C++)
```C++)
class Solution {
public:
    string longestPalindrome(string s) {
        
    }
};
```

## Solution (Java)
```Java)
class Solution {
    public String longestPalindrome(String s) {
        
    }
}
```

## Solution (Python)
```Python)
class Solution(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        
```

## Solution (Python3)
```Python3)
class Solution:
    def longestPalindrome(self, s: str) -> str:
        
```

## Solution (C)
```C)
char* longestPalindrome(char* s) {
    
}
```

## Solution (C#)
```C#)
public class Solution {
    public string LongestPalindrome(string s) {
        
    }
}
```

## Solution (JavaScript)
```JavaScript)
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    
};
```

## Solution (TypeScript)
```TypeScript)
function longestPalindrome(s: string): string {
    
};
```

## Solution (PHP)
```PHP)
class Solution {

    /**
     * @param String $s
     * @return String
     */
    function longestPalindrome($s) {
        
    }
}
```

## Solution (Swift)
```Swift)
class Solution {
    func longestPalindrome(_ s: String) -> String {
        
    }
}
```

## Solution (Kotlin)
```Kotlin)
class Solution {
    fun longestPalindrome(s: String): String {
        
    }
}
```

## Solution (Dart)
```Dart)
class Solution {
  String longestPalindrome(String s) {
    
  }
}
```

## Solution (Go)
```Go)
func longestPalindrome(s string) string {
    
}
```

## Solution (Ruby)
```Ruby)
# @param {String} s
# @return {String}
def longest_palindrome(s)
    
end
```

## Solution (Scala)
```Scala)
object Solution {
    def longestPalindrome(s: String): String = {
        
    }
}
```

## Solution (Rust)
```Rust)
impl Solution {
    pub fn longest_palindrome(s: String) -> String {
        
    }
}
```

## Solution (Racket)
```Racket)
(define/contract (longest-palindrome s)
  (-> string? string?)
  )
```

## Solution (Erlang)
```Erlang)
-spec longest_palindrome(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
longest_palindrome(S) ->
  .
```

## Solution (Elixir)
```Elixir)
defmodule Solution do
  @spec longest_palindrome(s :: String.t) :: String.t
  def longest_palindrome(s) do
    
  end
end
```

